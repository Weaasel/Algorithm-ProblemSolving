//색깔 하노이 탑
//Dynamic Programming
/*
  먼저 단순하게 생각하자.
  i-1층까지를 잘 옮겨두고, i층의 빨간원반을 옮기고, 그 위에 다시 i-1층까지를 잘 옮기고, 검은 원반을 도착지에 옮기고 앞선과정을 반복.
  이는 (dp[i-1]*2+1)*2+1 번의 작업횟수가 소요된다.
  그런데 이를 줄이고 싶다.
  꼭 '잘' 옮겨야 하나? 예컨대, 검은원반과 빨간 원반의 순서가 흐트러지면 안되나...?
  이 질문에 대한 답은 "된다"이다.
  
  하노이탑의 특성상 같은 작업을 두번씩 반복하게 되고, 이는 마치 XOR 연산처럼 "잘" 옮긴 것과 같은 결과를 낸다.
  따라서,
  dp[i][0]을 (i층까지 잘 옮기자)로,
  dp[i][1]을 (i층까지 대충 옮기자) 로 정의하면
  
  dp[i][0] = (dp[i - 1][1] * 2 + 1) * 2 + 1 가 된다.
  대충옮기는 것 역시 단순하게 구하면 된다.
  i-1층까지 대충 옮기고, 최하층의 2개를 그냥 옮기고, 다시 대충 옮기고.
  즉 dp[i][1] = dp[i - 1][1] * 2 + 2 이다.
*/

#include <bits/stdc++.h>
#define ll long long
const ll INF = 1e9 + 7;

using namespace std;

ll dp[1010100][2]; //0: 순서그대로 1:순서반대(맨아래층만)
int n;

int main(void) {
	ios::sync_with_stdio(0); cin.tie(0);
	cin >> n;
	dp[1][0] = 3;
	dp[1][1] = 2;
	for (int i = 2; i <= n; i++) {
		dp[i][0] = (dp[i - 1][1] * 2 + 1) * 2 + 1;
		dp[i][1] = dp[i - 1][1] * 2 + 2;
		dp[i][0] %= INF;
		dp[i][1] %= INF;
	}
	cout << dp[n][0];
	return 0;
}
